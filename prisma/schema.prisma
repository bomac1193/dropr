// DROPR Prisma Schema
// AI Music Battle Platform with Taste Graph

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
}

// =============================================================================
// Player & Identity (Roblox-linked)
// =============================================================================

model Player {
  id            String   @id @default(cuid())
  robloxUserId  BigInt   @unique
  username      String
  displayName   String?
  avatarUrl     String?

  // PULSE Profile
  pulseProfile  PulseProfile?

  // Stats
  influenceScore    Float    @default(0)
  totalTasteStakes  Float    @default(0)
  hypePoints        Int      @default(0)
  battleCount       Int      @default(0)
  winCount          Int      @default(0)

  // Timestamps
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  lastActiveAt  DateTime @default(now())

  // Relations
  battlesAsPlayer1  Battle[]    @relation("Player1")
  battlesAsPlayer2  Battle[]    @relation("Player2")
  votes             Vote[]
  tasteStakes       TasteStake[]
  remixSelections   RemixSelection[]

  @@index([robloxUserId])
  @@index([username])
  @@index([influenceScore])
}

// =============================================================================
// PULSE Profile (Taste Archetype System)
// =============================================================================

model PulseProfile {
  id        String  @id @default(cuid())
  playerId  String  @unique
  player    Player  @relation(fields: [playerId], references: [id], onDelete: Cascade)

  // Primary archetype
  archetype   PulseArchetype @default(CROWD_SURFER)

  // Taste vector (0-100 for each dimension)
  energy              Float @default(50)  // Low energy → High energy
  experimentalism     Float @default(50)  // Traditional → Experimental
  culturalAlignment   Float @default(50)  // Underground → Mainstream
  temporalTiming      Float @default(50)  // Early adopter → Late majority
  emotionalIntensity  Float @default(50)  // Chill → Intense
  rhythmComplexity    Float @default(50)  // Simple → Complex
  productionPolish    Float @default(50)  // Lo-fi → Hi-fi
  vocalsPreference    Float @default(50)  // Instrumental → Vocal-heavy
  genreFluidity       Float @default(50)  // Purist → Genre-fluid
  nostalgia           Float @default(50)  // Forward-looking → Retro

  // Derived scores
  predictionAccuracy  Float @default(50)  // 0-100, how well they predict winners
  trendsetterScore    Float @default(50)  // 0-100, early adoption of winning sounds
  tasteCoherence      Float @default(50)  // 0-100, consistency of choices

  // Metadata
  battlesSinceUpdate  Int      @default(0)
  lastComputedAt      DateTime @default(now())

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

enum PulseArchetype {
  TRENDSETTER     // First to spot winners, high prediction accuracy
  PURIST          // Deep genre knowledge, consistent taste
  CHAOS_AGENT     // Loves upsets, experimental choices
  CROWD_SURFER    // Goes with popular flow, high social alignment
  ARCHITECT       // Appreciates production complexity
  MOOD_SHIFTER    // Reads emotional energy, context-aware
}

// =============================================================================
// Sound Library
// =============================================================================

model Sound {
  id          String       @id @default(cuid())
  name        String
  description String?

  // Categorization
  category    SoundCategory
  rarity      SoundRarity   @default(COMMON)
  tags        String[]      @default([])

  // Audio data
  audioUrl    String
  duration    Int           // Duration in milliseconds
  bpm         Float?
  key         String?       // Musical key (e.g., "C minor")

  // Metrics
  useCount    Int           @default(0)
  winRate     Float         @default(50)  // % of battles won when chosen
  viralScore  Float         @default(0)   // 0-100

  // Timestamps
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  remixes     Remix[]
  battles     Battle[]

  @@index([category])
  @@index([rarity])
  @@index([viralScore])
}

enum SoundCategory {
  BRAIN_ROT    // Skibidi, Grimace, Ohio memes
  VIRAL        // Current trending sounds
  CLASSIC      // Timeless/nostalgic
  RARE         // Limited edition
  SEASONAL     // Event-specific
}

enum SoundRarity {
  COMMON
  RARE
  EPIC
  LEGENDARY
}

// =============================================================================
// AI-Generated Remixes
// =============================================================================

model Remix {
  id          String      @id @default(cuid())
  soundId     String
  sound       Sound       @relation(fields: [soundId], references: [id], onDelete: Cascade)

  // Remix details
  genre       RemixGenre
  name        String
  description String?

  // Audio data
  audioUrl    String
  duration    Int         // Duration in milliseconds

  // AI generation metadata
  generatedBy String      @default("suno")  // suno, udio, stable-audio
  prompt      String?     // AI prompt used
  modelVersion String?

  // Metrics
  selectCount Int         @default(0)  // Times selected by players
  winCount    Int         @default(0)  // Times this remix won
  winRate     Float       @default(50)

  createdAt   DateTime @default(now())

  // Relations
  selections  RemixSelection[]

  @@unique([soundId, genre])
  @@index([soundId])
  @@index([genre])
}

enum RemixGenre {
  TRAP
  HOUSE
  DUBSTEP
  PHONK
  DRILL
  HYPERPOP
  JERSEY_CLUB
  AMBIENT
}

// =============================================================================
// Battle System
// =============================================================================

model Battle {
  id              String       @id @default(cuid())

  // Players
  player1Id       String
  player2Id       String
  player1         Player       @relation("Player1", fields: [player1Id], references: [id])
  player2         Player       @relation("Player2", fields: [player2Id], references: [id])

  // Sound used
  soundId         String
  sound           Sound        @relation(fields: [soundId], references: [id])

  // Battle state
  status          BattleStatus @default(SELECTING)

  // Timing
  selectingEndsAt DateTime?
  playingEndsAt   DateTime?
  votingEndsAt    DateTime?

  // Results
  winnerId        String?
  player1Votes    Int          @default(0)
  player2Votes    Int          @default(0)
  crowdEnergy     Float        @default(0)  // 0-100, engagement level

  // Scene/Arena
  scene           String       @default("warehouse_rave")

  createdAt       DateTime     @default(now())
  updatedAt       DateTime     @updatedAt
  completedAt     DateTime?

  // Relations
  votes           Vote[]
  remixSelections RemixSelection[]
  tasteStakes     TasteStake[]

  @@index([status])
  @@index([player1Id])
  @@index([player2Id])
  @@index([createdAt])
}

enum BattleStatus {
  MATCHING       // Finding opponent
  SELECTING      // Players choosing remixes
  PLAYING_P1     // Playing player 1's remix
  PLAYING_P2     // Playing player 2's remix
  VOTING         // Crowd voting
  COMPLETED      // Battle finished
  CANCELLED      // Battle cancelled
}

// =============================================================================
// Remix Selections (Which remix each player chose)
// =============================================================================

model RemixSelection {
  id        String   @id @default(cuid())
  battleId  String
  playerId  String
  remixId   String

  battle    Battle   @relation(fields: [battleId], references: [id], onDelete: Cascade)
  player    Player   @relation(fields: [playerId], references: [id])
  remix     Remix    @relation(fields: [remixId], references: [id])

  selectedAt DateTime @default(now())

  @@unique([battleId, playerId])
  @@index([battleId])
  @@index([playerId])
}

// =============================================================================
// Voting
// =============================================================================

model Vote {
  id        String   @id @default(cuid())
  battleId  String
  voterId   String

  battle    Battle   @relation(fields: [battleId], references: [id], onDelete: Cascade)
  voter     Player   @relation(fields: [voterId], references: [id])

  // Vote choice: which player's remix they preferred
  votedFor  VoteChoice

  // Metadata
  confidence Float    @default(50)  // 0-100, how confident voter was
  votedAt    DateTime @default(now())

  @@unique([battleId, voterId])
  @@index([battleId])
  @@index([voterId])
}

enum VoteChoice {
  PLAYER_1
  PLAYER_2
}

// =============================================================================
// Taste Stakes (Training data value)
// =============================================================================

model TasteStake {
  id          String   @id @default(cuid())
  playerId    String
  battleId    String

  player      Player   @relation(fields: [playerId], references: [id])
  battle      Battle   @relation(fields: [battleId], references: [id], onDelete: Cascade)

  // Stake value
  influenceWeight     Float    @default(1.0)  // Based on player's influence
  appreciationValue   Float    @default(0)    // Grows as AI improves

  // Context
  chosenRemixGenre    RemixGenre
  wasWinner           Boolean  @default(false)
  predictionCorrect   Boolean  @default(false)

  createdAt   DateTime @default(now())

  @@unique([playerId, battleId])
  @@index([playerId])
  @@index([battleId])
  @@index([appreciationValue])
}

// =============================================================================
// Matchmaking Queue
// =============================================================================

model MatchmakingQueue {
  id          String   @id @default(cuid())
  playerId    String   @unique

  // Matching preferences
  minInfluence Float   @default(0)
  maxInfluence Float   @default(100000)
  preferredScene String?

  // Queue timing
  joinedAt    DateTime @default(now())
  expiresAt   DateTime

  @@index([joinedAt])
}

// =============================================================================
// Leaderboard Snapshots
// =============================================================================

model LeaderboardSnapshot {
  id          String   @id @default(cuid())

  type        LeaderboardType
  period      String   // "daily", "weekly", "all-time"

  // Snapshot data (JSON array of {playerId, rank, score})
  rankings    Json

  createdAt   DateTime @default(now())

  @@index([type, period])
  @@index([createdAt])
}

enum LeaderboardType {
  INFLUENCE       // By influence score
  WIN_RATE        // By battle win rate
  TRENDSETTER     // By prediction accuracy
  HYPE            // By hype points
}

// =============================================================================
// Daily Challenges
// =============================================================================

model DailyChallenge {
  id          String   @id @default(cuid())

  title       String
  description String

  // Challenge type
  type        ChallengeType
  targetValue Int         // e.g., "Win 3 battles" → 3

  // Rewards
  hypeReward  Int         @default(100)

  // Active period
  activeDate  DateTime    @db.Date

  createdAt   DateTime    @default(now())

  // Player completions
  completions ChallengeCompletion[]

  @@unique([activeDate, type])
  @@index([activeDate])
}

model ChallengeCompletion {
  id           String   @id @default(cuid())
  challengeId  String
  playerId     String

  challenge    DailyChallenge @relation(fields: [challengeId], references: [id], onDelete: Cascade)

  progress     Int      @default(0)
  completed    Boolean  @default(false)
  completedAt  DateTime?

  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  @@unique([challengeId, playerId])
  @@index([playerId])
}

enum ChallengeType {
  WIN_BATTLES          // Win X battles
  USE_SOUND_CATEGORY   // Use sounds from category X times
  VOTE_IN_BATTLES      // Vote in X battles
  USE_SPECIFIC_GENRE   // Select X remix genre
  EARN_HYPE            // Earn X hype points
}

// =============================================================================
// Content System (Quiz/Feed)
// =============================================================================

model ContentItem {
  id             String      @id @default(cuid())
  contentType    ContentType
  title          String?
  description    String?
  thumbnailUrl   String?
  contentUrl     String?
  featureEmbedding Float[]   @default([])
  tags           String[]    @default([])
  subcultureId   String?

  subculture     SubcultureCluster? @relation(fields: [subcultureId], references: [id])
  interactions   UserContentInteraction[]

  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  @@index([contentType])
  @@index([subcultureId])
}

enum ContentType {
  image
  track
  ai_artifact
}

model UserContentInteraction {
  id              String          @id @default(cuid())
  userId          String
  contentId       String

  content         ContentItem     @relation(fields: [contentId], references: [id], onDelete: Cascade)

  interactionType InteractionType
  rating          Float?
  dwellTimeMs     Int?
  source          InteractionSource

  createdAt       DateTime @default(now())

  @@unique([userId, contentId, interactionType])
  @@index([userId])
  @@index([contentId])
}

enum InteractionType {
  view
  like
  dislike
  save
  share
  skip
}

enum InteractionSource {
  quiz
  swipe
  feed
}

// =============================================================================
// Subculture Clustering
// =============================================================================

model SubcultureCluster {
  id                  String   @id @default(cuid())
  clusterId           String   @unique
  name                String?
  stage               SubcultureStage @default(forming)
  coherence           Float    @default(0.5)
  memberCount         Int      @default(0)
  aestheticConstraints Json    @default("{}")
  centroid            Json?
  tags                String[] @default([])
  constellationHints  String[] @default([])
  embeddingVector     Float[]  @default([])

  contentItems        ContentItem[]
  userFits            UserSubcultureFit[]

  createdAt           DateTime @default(now())
  updatedAt           DateTime @updatedAt

  @@index([stage])
  @@index([coherence])
}

enum SubcultureStage {
  forming
  stable
  dissolving
  mainstreaming
}

model UserSubcultureFit {
  id               String   @id @default(cuid())
  userId           String
  subcultureId     String

  subculture       SubcultureCluster @relation(fields: [subcultureId], references: [id], onDelete: Cascade)

  affinityScore    Float
  earlyAdopterScore Float
  adoptionStage    AdoptionStage

  firstSeenAt      DateTime @default(now())
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  @@unique([userId, subcultureId])
  @@index([userId])
  @@index([subcultureId])
}

enum AdoptionStage {
  early
  mid
  late
}
